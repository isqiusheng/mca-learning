# 并发编程三大特性

- 可见性（visibility）
- 有序性（ordering）
- 原子性（atomicity）

## 可见行
线程的底层知识（可见性 有序性 原子性）
 - 线程的执行
线程的调度（Context Switch）
 - 一个核同一时刻，只能运行一个线程

### 线程间的可见性

**MESI**

多线程提高效率，本地缓存数据，造成数据修改不可见，

要想保证可见，要么触发同步指令，要么加上volatile，被修饰的内存，只要有修改，马上同步涉及到的每个线程

```java
/**
 * volatile 关键字，使一个变量在多个线程间可见
 * A B线程都用到一个变量，java默认是A线程中保留一份copy，这样如果B线程修改了该变量，则A线程未必知道
 * 使用volatile关键字，会让所有线程都会读到变量的修改值
 * <p>
 * 在下面的代码中，running是存在于堆内存的t对象中
 * 当线程t1开始运行的时候，会把running值从内存中读到t1线程的工作区，在运行过程中直接使用这个copy，并不会每次都去
 * 读取堆内存，这样，当主线程修改running的值之后，t1线程感知不到，所以不会停止运行
 * <p>
 * 使用volatile，将会强制所有线程都去堆内存中读取running的值
 * <p>
 * volatile并不能保证多个线程共同修改running变量时所带来的不一致问题，也就是说volatile不能替代synchronized
 */
public class HelloVolatile {

    private static volatile boolean running = true;

    private static void m() {
        System.out.println("m start");
        while (running) {
            // 如果不加 volatile，里面加上println()语句，过一段时间，也会停止。因为println()方法里面用到了 synchronized，会导致缓存值刷新
            //System.out.println("hello"); 
        }
        System.out.println("m end!");
    }

    public static void main(String[] args) {

        new Thread(HelloVolatile::m, "t1").start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        running = false;
    }
}
```

### 缓存行对齐

- 缓存行对齐 缓存行64个字节是CPU同步的基本单位，缓存行隔离会比伪共享效率要高 Disruptor
- 认识缓存行对齐的编程技巧

```java
import java.util.concurrent.CountDownLatch;

/**
 * @author liufei
 * @version 1.0.0
 * @description
 * @date 2022/10/18
 */
public class CacheLinePadding {
    public static long COUNT = 10_0000_0000L;

    private static class T {
        private long p1, p2, p3, p4, p5, p6, p7;
        public long x = 0L;
        private long p9, p10, p11, p12, p13, p14, p15;
    }

    public static T[] arr = new T[2];

    static {
        arr[0] = new T();
        arr[1] = new T();
    }

    public static void main(String[] args) throws Exception {
        CountDownLatch latch = new CountDownLatch(2);

        Thread t1 = new Thread(() -> {
            for (long i = 0; i < COUNT; i++) {
                arr[0].x = i;
            }

            latch.countDown();
        });

        Thread t2 = new Thread(() -> {
            for (long i = 0; i < COUNT; i++) {
                arr[1].x = i;
            }

            latch.countDown();
        });

        final long start = System.nanoTime();
        t1.start();
        t2.start();
        latch.await();
        System.out.println((System.nanoTime() - start) / 100_0000);
    }
}
```

**需要注意，JDK8引入了@sun.misc.Contended注解，来保证缓存行隔离效果** 要使用此注解，必须去掉限制参数：-XX:-RestrictContended

```java
import sun.misc.Contended;
import java.util.concurrent.CountDownLatch;

//注意：运行这个小程序的时候，需要加参数：-XX:-RestrictContended
public class CacheLinePadding {
    public static long COUNT = 10_0000_0000L;

    private static class T {
        //private long p1, p2, p3, p4, p5, p6, p7;
        @Contended  //只有1.8起作用 , 保证x位于单独一行中
        public long x = 0L;
        //private long p9, p10, p11, p12, p13, p14, p15;
    }

    public static T[] arr = new T[2];

    static {
        arr[0] = new T();
        arr[1] = new T();
    }

    public static void main(String[] args) throws Exception {
        CountDownLatch latch = new CountDownLatch(2);

        Thread t1 = new Thread(() -> {
            for (long i = 0; i < COUNT; i++) {
                arr[0].x = i;
            }

            latch.countDown();
        });

        Thread t2 = new Thread(() -> {
            for (long i = 0; i < COUNT; i++) {
                arr[1].x = i;
            }

            latch.countDown();
        });

        final long start = System.nanoTime();
        t1.start();
        t2.start();
        latch.await();
        System.out.println((System.nanoTime() - start) / 100_0000);
    }
}
```
![缓存行](./imag/缓存行.png)

**缓存一致性协议和volatile无关**

> 缓存行：
>
> 缓存行越大，局部性空间效率越高，但读取时间慢
>
> 缓存行越小，局部性空间效率越低，但读取时间快
>
> 取一个折中值，目前多用：
>
> 64字节

![MESI_Cache一致性](./imag/MESI_Cache一致性.png)

### 伪共享

![image-20221018233839796](./imag/cacheline-伪共享.png)

## 有序性

