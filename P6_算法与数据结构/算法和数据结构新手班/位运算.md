## 1.位运算概述

从现代计算机中所有的数据二进制的形式存储在设备中。即 0、1 两种状态，计算机对二进制数据进行的运算(+、-、*、/)都是叫位运算，即将符号位共同参与运算的运算。

口说无凭，举一个简单的例子来看下 CPU 是如何进行计算的，比如这行代码：

```java
int a = 35;
int b = 47;
int c = a + b;
```

计算两个数的和，因为在计算机中都是以二进制来进行运算，所以上面我们所给的 int 变量会在机器内部先转换为二进制在进行相加：

在java中int类型是32位，占4个字节

```java
35: 0000 0000 0000 0000 0000 0000 0010 0011
47: 0000 0000 0000 0000 0000 0000 0010 1111
—————————————————————————————————————————————
82: 0000 0000 0000 0000 0000 0000 0101 0010
```

左边是十进制，右边是二进制（满2进1）

所以，相比在代码中直接使用(+、-、*、/)运算符，合理的运用位运算更能显著提高代码在机器上的执行效率。

## 2.位运算概览

|符号 |	描述 |	运算规则|
|--|--|--|
|&	| 与	| 两个位都为1时，结果才为1 |
|`|`| 或	| 两个位都为0时，结果才为0 |
|^	| 异或	| 两个位相同为0，相异为1 |
|~	| 取反	| 0变1，1变0|
|<<	| 左移	| 各二进位全部左移若干位，高位丢弃，低位补0|
|>>	| 右移	| 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）|
|>>>	| 无符号右移	| 无符号右移，java中最高位全部补0 |

## 3.位运算相关例子

### 3.1 & （与）

运算规则：

**两位都为1，结果才是1**

```java
0&0=0  0&1=0  1&0=0  1&1=1
```

```java
// 计算 3 & 2 = 2

3: 0000 0000 0000 0000 0000 0000 0000 0011
2: 0000 0000 0000 0000 0000 0000 0000 0010
—————————————————————————————————————————————
2: 0000 0000 0000 0000 0000 0000 0000 0010
```

**注意：负数按补码形式参加按位与运算。**


### 3.2 | （或）

运算规则：

**两位只要有一个为1，结果才是1**

```java
0&0=0  0&1=1  1&0=1  1&1=1
```

```java
// 计算 3 | 2 = 3

3: 0000 0000 0000 0000 0000 0000 0000 0011
2: 0000 0000 0000 0000 0000 0000 0000 0010
—————————————————————————————————————————————
3: 0000 0000 0000 0000 0000 0000 0000 0011
```

### 3.3 异或 （^）

运算规则：

**两位相同为0，相异为1**

```java
0&0=0  0&1=1  1&0=1  1&1=0
```

```java
// 计算 3 ^ 2 = 1

3: 0000 0000 0000 0000 0000 0000 0000 0011
2: 0000 0000 0000 0000 0000 0000 0000 0010
—————————————————————————————————————————————
1: 0000 0000 0000 0000 0000 0000 0000 0001
```

### 3.4 取反 （~）

运算规则：

**0变1，1变0**

```java
~0=1  ~1=0
```

```java
    // 计算 ~2 = 3

    2: 0000 0000 0000 0000 0000 0000 0000 0010
~   —————————————————————————————————————————————
   -3: 1111 1111 1111 1111 1111 1111 1111 1101
```

最高位为1，表明是个负数，然后值怎么算法呢？

**取反 + 1**

```shell
如：

1111 1111 1111 1111 1111 1111 1111 1101

最高位是1，表明去其是个负号，值的话，我们队剩下的31位取反 + 1

先取反 => 1 000 0000 0000 0000 0000 0000 0000 0010

再加1 =>  1 000 0000 0000 0000 0000 0000 0000 0011

000 0000 0000 0000 0000 0000 0000 0011 对应的数就是3

所以 ~2 = 3
```

### 3.5 <<（左移）

左移(整体左移)一位相当与 乘以 2，左移之后，末尾补0

```java
    // 计算 2 << 1 = 4

    2: 0000 0000 0000 0000 0000 0000 0000 0010
<<  —————————————————————————————————————————————
    4: 0000 0000 0000 0000 0000 0000 0000 0100
```

```java
    // 计算 50 << 1 = 100

    50:  0000 0000 0000 0000 0000 0000 0011 0010
<<  —————————————————————————————————————————————
    100: 0000 0000 0000 0000 0000 0000 0110 0100
```

### 3.6 >> （右移，又称有符号右移）

**右移一位相当于除以2**

32位，从左往右第一位(又称最高位)被称之为符号为，1表示负号，0表示非负号

那么右移一位，如果是非负数，往最高位补0，如果是负数，往最高位补1

```java
    // 计算 50 >> 1 = 25

    50:  0000 0000 0000 0000 0000 0000 0011 0010
<<  —————————————————————————————————————————————
    25:  0000 0000 0000 0000 0000 0000 0001 1001

    // 计算 3 >> 1 = 1，直接丢弃末尾的1

    3:  0000 0000 0000 0000 0000 0000 0000 0011
<<  —————————————————————————————————————————————
    1:  0000 0000 0000 0000 0000 0000 0000 0000

    // 计算 -4 >> 1 = -2

    -4:  1111 1111 1111 1111 1111 1111 1111 1100
<<  —————————————————————————————————————————————
    -2:  1111 1111 1111 1111 1111 1111 1111 1110
```


### 3.7 >>> （无符号右移）

**右移一位相当于除以2**

32位，从左往右第一位(又称最高位)被称之为符号为，1表示负号，0表示非负号

那么右移一位，无论是什么数，直接往最高位补0



```java
    // 计算 -4 >>> 1 = 2147483646
    -4:          1111 1111 1111 1111 1111 1111 1111 1100
<<  —————————————————————————————————————————————
    2147483646:  0111 1111 1111 1111 1111 1111 1111 1110
```

## 4. 原码、反码和补码

### 4.1 十进制和二进制的转换

**1. 十进制转换为二进制，分为整数部分和小数部分。**

> - **整数部分采用除2倒取余法**，具体做法：用2去除十进制整数，可以得到一个商和余数；在用2去除商，又会得到一个商和余数，如此进行，知道商为0时为止，然后把先的到的余数作为二进制的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。
> 
> - **小数部分采用乘2取整法**，具体做法：用2乘十进制小数，可以得到积，将积中的整数部分取出，在用2乘余下的小数部分，又得到一个积，在将积中的整数部分取出，如此进行，直到积中的小数部分为0，此时0或1为二进制的最后一位，或者达到所要求的精度为止，然后把取出的整数部分按顺序排列起来，先取得整数作为二进制小数的最高位有效位，后取的整数作为低位有效位。

**2. 二进制转换为十进制，方法：按权相加法，即将二进制每位上的数乘以权，然后相加之和即是十进制数。**

这个转换数学都学过，这里就不展开了

### 4.2 原码

是最简单的机器数表示法，用最高位表示符号位，其他位存放该数的二进制的绝对值。

以带符号位的四位二进制数为例：1010，最高位为1表示这是一个负数，其它三位010，即0 * 2² + 1 * 2¹ + 0 * 2º=2，所以1010表示十进制数-2。

|      | 正数 |      | 负数 |
| ---- | ---- | ---- | ---- |
| 0    | 0000 | -0   | 1000 |
| 1    | 0001 | -1   | 1001 |
| 2    | 0010 | -2   | 1010 |
| 3    | 0011 | -3   | 1011 |
| 4    | 0100 | -4   | 1100 |
| 5    | 0101 | -5   | 1101 |
| 6    | 0110 | -6   | 1110 |
| 7    | 0111 | -7   | 1111 |

原码的表示法很简单，虽然出现了+0 和 -0，但是直观易懂。于是开始运算——

```shell
0001+0010=0011，1+2=3；
0000+1000=1000，+0+(-0)=-0；
0001+1001=1010，1+(-1)=-2。
```

于是可以看到其实正数之间的加法通常是不会出错的，因为它就是一个很简单的二进制加法，而正数与负数相加，或负数与负数相加，就要引起莫名其妙的结果，这都是符号位引起的。0分为+0和-0也是因它而起。

**原码的特点：**

1. 原码表示直观、易懂，与真值转换容易。

2. 原码中0有两种不同的表示形式，给使用带来了不便。

> 通常0的原码用+0表示，若在计算过程中出现了-0，则需要用硬件将-0变成+0。

3. 原码表示加减运算复杂。

> 利用原码进行两数相加运算时，首先要判别两数符号，若同号则做加法，若异号则做减法。在利用原码进行两数相减运算时，不仅要判别两数符号，使得同号相减，异号相加；还要判别两数绝对值的大小，用绝对值大的数减去绝对值小的数，取绝对值大的数的符号为结果的符号。可见，原码表示不便于实现加减运算。



### 4.3 **反码**

**原码最大的问题就在于一个数加上它的相反数不等于0**，于是反码的设计思想就是冲着解决这一点，既然一个负数是一个正数的相反数，那干脆用一个正数按位取反来表示负数。

反码：**正数的反码还是等于原码；负数的反码就是它的原码除符号位外，按位取反**。

以带符号位的四位二进制数为例：3是正数，反码与原码相同，则可以表示为0011；-3的原码是1011，符号位保持不变，低三位按位取反，所以-3的反码为1100。

再试着用反码的方式解决一下原码的问题——

```shell
0001+1110=1111，1+(-1)=-0；
1110+1100=1010，(-1)+(-3)=-5。
```

互为相反数相加等于0，虽然的到的结果是1111也就是-0。**但是两个负数相加的出错了**。

**反码的特点：**

- 在反码表示中，用符号位表示数值的正负，形式与原码表示相同，即0为正；1为负。
- 在反码表示中，数值0有两种表示方法。
- 反码的表示范围与原码的表示范围相同。


**反码表示在计算机中往往作为数码变换的中间环节。**

### 4.4 补码

补码：**正数的补码等于它的原码；负数的补码等于反码+1**（这只是一种算补码的方式，多数书对于补码就是这句话）。

其实负数的补码等于反码+1只是补码的求法，而不是补码的定义，很多人以为求补码就要先求反码，其实并不是，那些计算机学家并不会心血来潮的把反码+1就定义为补码，**只不过补码正好就等于反码+1而已。**

如果有兴趣了解补码的严格说法，建议可以看一下《计算机组成原理》，它会用“模”和“同余”的概念，严谨地解释补码。

3的原码： 0011
-3的原码：1011
-3的反码：1100
-3的补码：1101

```shell
0011 + 1101 = 1000, (3) + (-3) = -0。
0001 + 1101 = 1010，(1) + (-3) = -2。
```

所以计算机中的数的计算，是使用数的补码来计算的

java程序中一个数的二进制，也是补码

```shell
// -3的二进制
1111 1111 1111 1111 1111 1111 1111 1101 
```

**补码的思想**

补码的思想，第一次见可能会觉得很绕，但是如果肯停下来仔细想想，绝对会觉得非常美妙。

补码的思想其实就是来自于生活，只是我们没注意到而已，如时钟、经纬度、《易经》里的八卦等。**补码的思想其实就类似于生活中的时钟**。

如果说现在时针现在停在10点钟，那么什么时候会停在八点钟呢？

> 简单，过去隔两个小时的时候是八点钟，未来过十个小时的时候也是八点钟。
> 也就是说时间倒拨2小时，或正拨10小时都是八点钟。
> 也就是10-2=8，而且10+10=8。
> 这个时候满12，说明时针在走第二圈，又走了8小时，所以时针正好又停在八点钟。

所以12在时钟运算中，称之为模，超过了12就会重新从1开始算了。

也就是说，10-2和10+10从另一个角度来看是等效的，它都使时针指向了八点钟。

既然是等效的，那么在时钟运算中，减去一个数，其实就相当于加上另外一个数（这个数与减数相加正好等于12，也称为同余数），这就是补码所谓运算思想的生活例子。

在这里，再次强调原码、反码、补码的引入是为了解决做减法的问题。在原码、反码表示法中，我们把减法化为加法的思维是减去一个数等于加上这个数的相反数，结果发现引入符号位，却因为符号位造成了各种意想不到的问题。

但是从上面的例子中，可以看到其实减去一个数，对于数值有限制、有溢出的运算（模运算）来说，其实也相当于加上这个数的同余数。

也就是说，不引入负数的概念，就可以把减法当成加法来算。

### 4.5 **为什么负数的补码的求法是反码+1？**

因为负数的反码加上这个负数的绝对值正好等于1111，在加1，就是10000，也就是四位二进数的模，而负数的补码是它的绝对值的同余数，可以通过模减去负数的绝对值得到它的补码，所以负数的补码就是它的反码+1。

如：

-3的反码：1100

3的原码： 0011

刚好为：1111，再加上1为1 0000

> 其实这样底层可以走一套逻辑，不然还要判断正负，很底层的东西，需要保证效率

**// TODO 不是很懂，标记一下**

## 5. 位运算的用途

### 5.1 与(&)

#### 1) 清零（使用&）

如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。

```java
// 各位数都以为0的就是0了，就是任意一个数，只要与上0结果就是0。
// 与运算，都为1才是1，其他情况都是0
3 & 0 = 0
```

#### 2) 取一个数的指定位（使用&）

比如取数 X=1010 1110 的低4位，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位与运算（X&Y=0000 1110）即可得到X的指定位。

#### 3) 判断奇偶（使用&）

只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((a & 1) == 0)代替if (a % 2 == 0)来判断a是不是偶数。


### 5.2 或(|)

#### 1) 常用来对一个数据的某些位设置为1（使用|）

比如将数 X=1010 1110 的低4位设置为1，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位或运算（X|Y=1010 1111）即可得到。


### 5.3 异或(^)

#### 1) 翻转指定位

比如将数 X=1010 1110 的低4位进行翻转，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行异或运算（X^Y=1010 0001）即可得到。

#### 2) 与0相异或值不变

例如：1010 1110 ^ 0000 0000 = 1010 1110

#### 3) 交换两个数

```java
 public void swap(int i, int j) {
    i = i ^ j;
    j = j ^ i;
    i = i ^ j;
}
```

### 5.4 取反(~)

#### 1) 使一个数的最低位为零

使a的最低位为0，可以表示为：a & ~1。~1的值为 1111 1111 1111 1110，再按"与"运算，最低位一定为0。因为" ~"运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。

#### 2) 取一个数的相反数

如取5的相反数 c = ~5 + 1

## 6 写个程序，求一个数的二进制

```java
public void printBinary(int num) {
    for (int i = 31; i >= 0; i--) {
        System.out.print((num & (1 << i)) == 0 ? '0' : '1');
    }
}
```

假设num=5

5的二进制是：0000 0000 0000 0000 0000 0000 0000 0101

1的二进制是：0000 0000 0000 0000 0000 0000 0000 0001

```shell
左移31位是： 1000 0000 0000 0000 0000 0000 0000 0000

再与num是：  0000 0000 0000 0000 0000 0000 0000 0000  就是 0

...

左移1位是： 0000 0000 0000 0000 0000 0000 0000 0010
再与num是： 0000 0000 0000 0000 0000 0000 0000 0000  就是 0

左移0位是： 0000 0000 0000 0000 0000 0000 0000 0001
再与num是： 0000 0000 0000 0000 0000 0000 0000 0001  就是1
```

## 7. java中int的最小值相反数是多少？

java中的int占4个字节，32位

最高位应该是2的32次方

但是java中int的取值是[2^31, 2^31 - 1]，因为int包含正负

用上面的程序算出int的最小值二进制是：1000 0000 0000 0000 0000 0000 0000 0000 

利用上面的取反公式：一个数N的相反数是 ~N + 1

那么int最小值二进制取反是：0111 1111 1111 1111 1111 1111 1111 1111

再加上1又是：1000 0000 0000 0000 0000 0000 0000 0000 

所以：int的最小值的相反数或者绝对值还是它自己

```java
int c = Integer.MIN_VALUE;
System.out.println(c);
System.out.println(-c);  // 还是它自己 
System.out.println(Math.abs(c)); // 还是它自己
```

**总结：正数的相反数一定是负数，但是负数的相反数不一定是正数**