# 什么是数据结构？

数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。—— [百度百科]

# 数据结构分类

## 线性结构

1. 线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系
2. 线性结构有两种不同的存储结构，即顺序存储结构(数组)和链式存储结构(链表)。顺序存储的线性表称为顺序 表，顺序表中的存储元素是连续的
3. 链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地 址信息
4. 线性结构常见的有：数组、队列、链表和栈。

## 非线性结构

非线性结构包括：二维数组，多维数组，广义表，树结构，图结构

# 常见的数据结构
## 数组(Array)
数组是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。数组可以说是最基本的数据结构，在各种编程语言中都有对应。一个数组可以分解为多个数组元素，按照数据元素的类型，数组可以分为整型数组、字符型数组、浮点型数组、指针数组和结构数组等。数组还可以有一维、二维以及多维等表现形式。 

## 栈( Stack)
栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。栈按照先进后出或后进先出的原则来存储数据，也就是说，先插入的数据将被压入栈底，最后插入的数据在栈顶，读出数据时，从栈顶开始逐个读出。栈在汇编语言程序中，经常用于重要数据的现场保护。栈中没有数据时，称为空栈。 

## 队列(Queue)

队列和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。一般来说，进行插入操作的一端称为队尾，进行删除操作的一端称为队头。队列中没有元素时，称为空队列。 

## 链表( Linked List)

链表是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。链表由一系列数据结点构成，每个数据结点包括数据域和指针域两部分。其中，指针域保存了数据结构中下一个元素存放的地址。链表结构中数据元素的逻辑顺序是通过链表中的指针链接次序来实现的。

## 树( Tree)

树是典型的非线性结构，它是包括，2个结点的有穷集合K。在树结构中，有且仅有一个根结点，该结点没有前驱结点。在树结构中的其他结点都有且仅有一个前驱结点，而且可以有两个后继结点，m≥0。

## 图(Graph)

图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系。

## 堆(Heap)

堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。堆的特点是根结点的值是所有结点中最小的或者最大的，并且根结点的两个子树也是一个堆结构。 

## 散列表(Hash)

散列表源自于散列函数(Hash function)，其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录。 


# 什么是算法（Algorithm）？

同一问题的不同解决方法
算法往往是针对特定数据结构的


# 数据结构和算法的关系

1. 数据 data 结构(structure)是一门研究组织数据方式的学科，有了编程语言也就有了数据结构.学好数据结构可以 编写出更加漂亮,更加有效率的代码。
2. 要学习好数据结构就要多多考虑如何将生活中遇到的问题,用程序去实现解决.
3. 程序 = 数据结构 + 算法
4. 数据结构是算法的基础, 换言之，想要学好算法，需要把数据结构学到位。


# 如何测算算法的优劣？

## 时间测算
- 计算算法时间差
- 幅度不够循环来凑

## 空间测算


# Big O (大O标记法)

使用大O标记法来测算算法的优劣

- 时间-问题（数据）规模
  - 不考虑必须要做的操作
    - 循环、复制、程序初始化...
  - 不考虑常数项
    - 2n -> n
  - 不考虑地此项
    - n² + n -> n²

**一般说时间复杂度都是讲最差的情况下**

# 算法的复杂度
## 时间频度
一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，
哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。
一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。

## 时间复杂度
前面提到的时间频度T(n)中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律，为此我们引入时间复杂度的概念。
一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，
T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数，记作T(n)=O(f(n))，它称为算法的渐进时间复杂度，简称时间复杂度。

## 大O表示法
算法的时间复杂度，我们一般使用大O法表示。
大O表示法O(f(n))中的f(n)的值可以为1、n、logn、n²等，因此我们可以将O(1)、O(n)、O(logn)、O(n²)分别可以称为常数阶、线性阶、对数阶和平方阶，
那么如何推导出f(n)的值呢？我们接着来看推导大O阶的方法。

## 推导大O阶
推导大O阶，我们可以按照如下的规则来进行推导，得到的结果就是大O表示法：
1.用常数1来取代运行时间中所有加法常数。
2.修改后的运行次数函数中，只保留最高阶项
3.如果最高阶项存在且不是1，则去除与这个项相乘的常数。

### 常数阶
先举了例子，如下所示。
```java
  int sum = 0,n = 2;  //执行一次  
  sum = (1+n) * n;  //执行一次  
  System.out.println (sum); //执行一次 
```
上面算法的运行的次数的函数为f(n)=3，根据推导大O阶的规则1，我们需要将常数3改为1，则这个算法的时间复杂度为O(1)。
因为sum = (1+n) * n的执行次数与大小n并没有关系，所以这个算法的时间复杂度仍旧是O(1)，我们可以称之为常数阶。

### 线性阶
线性阶主要要分析循环结构的运行情况，如下所示。
```java
 for (int i = 0,i < n;i++) {
  // 时间复杂度为O(1)的算法
  ...
 }
```
上面算法循环体中的代码执行了n次，因此时间复杂度为O(n)。

### 对数阶
```java
  int number = 1;
  while(number < n) {
    number = number * 2;
    //时间复杂度为O(1)的算法
  }
```
可以看出上面的代码，随着number每次乘以2后，都会越来越接近n，当number不小于n时就会退出循环。
假设循环的次数为X，则由2^x=n得出x=log₂n，因此得出这个算法的时间复杂度为O(logn)。

### 平方阶
平方阶，也就是我们所说的循环嵌套。
```java
 for(int i=0;i<n;i++){   
      for(int j=0;j<n;j++){
         //复杂度为O(1)的算法
         ... 
      }
  }
```
内层循环的时间复杂度在讲到线性阶时就已经得知是O(n)，现在经过外层循环n次，那么这段算法的时间复杂度则为O(n²)。 

接下来我们来算一下下面算法的时间复杂度：
```java
for(int i=0;i<n;i++){   
      for(int j=i;j<n;j++){
         //复杂度为O(1)的算法
         ... 
      }
  }
```
需要注意的是内循环中int j=i，而不是int j=0。

当i=0时，内层循环执行了n次
当i=1时，内存循环执行了n-1次
......
当i=n-1时，内存循环执行了1次

所以总次数就是：
n + (n-1) + (n-2) + ... + 1 
= (n + 1)n / 2
= n²/2+n/2

根据此前讲过的推导大O阶的规则的第二条：只保留最高阶，因此保留n²/2。根据第三条去掉和这个项的常数，则去掉1/2,最终这段代码的时间复杂度为O(n²)。

### nlogn阶
f(n)=nlogn时，时间复杂度为O(nlogn)
```java
 int number = 1;
  while(number < nⁿ) {
    number = number * 2;
    //时间复杂度为O(1)的算法
  }
```
2 ^ x = nⁿ，则 x=nlogn

### 立方阶
f(n)=n³时，时间复杂度为O(n³)。这就是三层循环
```java
  for(int i = 0;i < n;i++ ) {
    for (int j = 0;j < n;j++) {
        for (int k = 0;k < n;k++) {
        ...
        //时间复杂度为O(1)的算法
        }
    }
  }
```
经过三层循环，时间复杂度为O(n³)

### 指数阶
f(n)=2ⁿ时，时间复杂度为O(2ⁿ)
```java
 for (int i = 0, i < 2ⁿ； i++) {
 }
```

### 阶乘阶
f(n)=n!时，时间复杂度为O(n!)

### 平方根阶
f(n)=(√n时，时间复杂度为O(√n)

## 复杂度的比较
下面将算法中常见的f(n)值根据几种典型的数量级来列成一张表，根据这种表，我们来看看各种算法复杂度的差异。

n     | logn | √n  | nlogn | n² | 2ⁿ |  n!
-------- | ----- | ----- | ----- | ----- | -----  | ---
5  | 2   | 2 | 10      |  25   | 32   | 120
10  | 2  | 3 | 20   |  100  | 1024  | 3628800
50  | 5  | 7 | 350  |  250  | 约10^15 | 约3.0*10^64
100  | 6  | 10 | 600  |  10000  | 约10^30 | 约9.3*10^157
1000  | 9  | 31 | 9000  |  1000 000  | 约10^300  | 约4.0*10^2567

从上表可以看出，O(n)、O(logn)、O(√n )、O(nlogn )随着n的增加，复杂度提升不大，因此这些复杂度属于效率高的算法，
反观O(2ⁿ)和O(n!)当n增加到50时，复杂度就突破十位数了，这种效率极差的复杂度最好不要出现在程序中，
因此在动手编程时要评估所写算法的最坏情况的复杂度。

常用的时间复杂度按照耗费的时间从小到大依次是：

> O(1)<O(logn)<O(n)<O(nlogn)<O(n²)<O(n³)<O(2ⁿ)<O(n!)

## 空间复杂度
一个算法的空间复杂度，一般是指执行这个算法所需的存储空间。
一个算法所占用的存储空间包括算法程序所占用的空间、输入的初始数据所占用的存储空间及算法执行过程中所需要的额外空间。